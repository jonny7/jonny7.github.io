<!doctype html><html lang=en-us><head><title>Go Concurrency - Part One // Jonny7.github.io</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.83.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Jonny"><meta name=description content><link rel=stylesheet href=https://jonny7.github.io/css/main.min.96dee62379d317c6fe03dc1ac43a50cb59592930980e1f7bcc1dccc341f24008.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Concurrency - Part One"><meta name=twitter:description content="This is going to be a little series on concurrency and Go. Just to capture some ideas and capabilities with the language, along with some code for solving real world problems. But first
What is Concurrency There is a load of descriptions of what concurrency is, often they&rsquo;re incorrectly describing parallelism. You can find loads of information, but a great talk is Rob Pike&rsquo;s concurrency is not parallelism. But in a nut shell, I really like the definition of concurrency being a property of code and parallelism being a property of execution."><meta property="og:title" content="Go Concurrency - Part One"><meta property="og:description" content="This is going to be a little series on concurrency and Go. Just to capture some ideas and capabilities with the language, along with some code for solving real world problems. But first
What is Concurrency There is a load of descriptions of what concurrency is, often they&rsquo;re incorrectly describing parallelism. You can find loads of information, but a great talk is Rob Pike&rsquo;s concurrency is not parallelism. But in a nut shell, I really like the definition of concurrency being a property of code and parallelism being a property of execution."><meta property="og:type" content="article"><meta property="og:url" content="https://jonny7.github.io/posts/go-concurrency/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-30T16:38:12-03:00"><meta property="article:modified_time" content="2020-06-30T16:38:12-03:00"></head><body><header class=app-header><a href=https://jonny7.github.io/><img class=app-header-avatar src=/avatar.jpg alt=Jonny></a><h1>Jonny7.github.io</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
·
<a class=app-header-menu-item href=/about/>About</a>
·
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>I'm a full stack engineer working with Go, Swift, TypeScript, MongoDB (certified), Oracle & Postgres, Docker & Kubernetes</p><div class=app-header-social><a href=https://github.com/jonny7 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Jonny7</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Go Concurrency - Part One</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 30, 2020</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://jonny7.github.io/tags/go/>go</a>
<a class=tag href=https://jonny7.github.io/tags/go-concurrency/>go-concurrency</a></div></div></header><div class=post-content><p>This is going to be a little series on concurrency and Go. Just to capture some ideas and capabilities with the language, along with some code for solving real world problems. But first</p><h3 id=what-is-concurrency>What is Concurrency</h3><p>There is a load of descriptions of what concurrency is, often they&rsquo;re incorrectly describing parallelism. You can find loads of information, but a great talk is Rob Pike&rsquo;s <a href="https://www.youtube.com/watch?v=oV9rvDllKEg">concurrency is not parallelism</a>. But in a nut shell, I really like the definition of concurrency being a property of code and parallelism being a property of execution. So essentially, design your code to be concurrent, but you execute it with the possibility of utilizing parallelism. Assuming you have multiple cores that is.</p><h3 id=concurrency-is-hard>Concurrency is hard</h3><p>Yeah&mldr; Spoiler alert, it&rsquo;s harder than it seems. I forget where I saw, heard, read this piece, but essentially, isn&rsquo;t it odd that <code>Go</code> has the flagship property of being concurrent from the ground up and it&rsquo;s really simple and intuitive to use it. Which generally it is. But all the books and tutorials around it are at the back of books and not in that much depth or use very non real-world examples. Here, watch me count a loop concurrently&mldr;.</p><h5 id=go-routines>Go routines</h5><p>A go routine is a very inexpensive way to introduce concurrency into your programs. Essentially, you use the <code>go</code> keyword to trigger it.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(){
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello from a go routine&#34;</span>)
    }()
}
</code></pre></div><p>If you run this, chances are you won&rsquo;t see any output. The go routine executes in its own context and is passed to the scheduler, which determines when it will run. You can use some timer after to make sure that the output is shown. So how do you get this information back between contexts?</p><h5 id=channels>Channels</h5><p>Channels allow for synchronization points between programs.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>)
    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>c</span> <span style=color:#66d9ef>chan</span>) {
        <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>) <span style=color:#75715e>// simulate work
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#e6db74>&#34;Hello from go routine&#34;</span>
    }(<span style=color:#a6e22e>c</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>)
    <span style=color:#75715e>// prints: Hello from go routine
</span><span style=color:#75715e></span>}
</code></pre></div><p>They are inherently blocking, which means whereas the previous example just exited, the main go routine will wait to receive the response from the go routine that is doing some work.</p><h5 id=another-example>Another example</h5><p>What do think will happen here?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>jobs</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
    <span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)

    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>jobs</span>, <span style=color:#a6e22e>results</span>)

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>jobs</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
    }
    close(<span style=color:#a6e22e>jobs</span>)
    
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>results</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>r</span>)
    }
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>jobs</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>results</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>){
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>jobs</span> {
        <span style=color:#a6e22e>results</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
    }
    close(<span style=color:#a6e22e>results</span>)
}
</code></pre></div><p><strong>Answer</strong>: Deadlock</p><p>These channels are unbuffered.</p><blockquote><p>In an unbuffered channel writing to the channel will not happen until there is some receiver waiting to receive the data.</p></blockquote><p>So our for loop for adding numbers to the <code>jobs</code> channel will block and create a deadlock. So, how can you fix this?</p><p><strong>Answer</strong>: One option is to use <a href=https://play.golang.org/p/MTqhQpA7R9o>buffered channels</a></p><p>Buffered channels work because they are non-blocking and assuming buffered channels work for your situation, you can simply change our channel declaration to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>jobs</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>10</span>)
<span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>10</span>)
</code></pre></div><p><strong>Another Answer</strong>: Wrap the the <code>jobs</code> loop in it&rsquo;s own <code>go</code> routine, while still using <a href=https://play.golang.org/p/l9wMPJoYVED>unbuffered channels</a>. This works because the <code>jobs</code> for loop is running in it&rsquo;s own context.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(){
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt;<span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>jobs</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
    }
    close(<span style=color:#a6e22e>jobs</span>)
}()
</code></pre></div><h5 id=closing-channels>Closing channels</h5><p>You can also close channels to help identify when a go routine won&rsquo;t receive any more data. A good rule here is</p><blockquote><p>only the sending go routine should close a channel</p></blockquote><p>That&rsquo;s assuming it&rsquo;s the only sender.</p><p>In the example above, we close the jobs <code>channel</code> from the sending side, knowing that there is no more data going to be sent along it. The same with the result <code>channel</code>, we close it at a point where no more records will be sent along it. In practice there are nicer ways to do this, with quit channels and <code>select</code> statements.</p><p>Another thing I missed when I first starting working with go, is that closing a channel does trigger a message to the receivers. Here&rsquo;s an example</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>jobs</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>jobs</span>)
    <span style=color:#75715e>// Deadlock :-(
</span><span style=color:#75715e></span>}
</code></pre></div><p>But if we close it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>jobs</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
    close(<span style=color:#a6e22e>jobs</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>jobs</span>)
    <span style=color:#75715e>// 0
</span><span style=color:#75715e></span>}
</code></pre></div><p>This is just a brief article into some basic concurrency, i&rsquo;ll look to add some more articles</p></div><div class=post-footer></div></article></main></body></html>