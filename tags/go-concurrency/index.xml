<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go-concurrency on Jonny7.github.io</title><link>https://jonny7.github.io/tags/go-concurrency/</link><description>Recent content in go-concurrency on Jonny7.github.io</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 30 Jun 2020 16:38:12 -0300</lastBuildDate><atom:link href="https://jonny7.github.io/tags/go-concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Concurrency - Part One</title><link>https://jonny7.github.io/posts/go-concurrency/</link><pubDate>Tue, 30 Jun 2020 16:38:12 -0300</pubDate><guid>https://jonny7.github.io/posts/go-concurrency/</guid><description>This is going to be a little series on concurrency and Go. Just to capture some ideas and capabilities with the language, along with some code for solving real world problems. But first
What is Concurrency There is a load of descriptions of what concurrency is, often they&amp;rsquo;re incorrectly describing parallelism. You can find loads of information, but a great talk is Rob Pike&amp;rsquo;s concurrency is not parallelism. But in a nut shell, I really like the definition of concurrency being a property of code and parallelism being a property of execution.</description></item></channel></rss>